#[allow(dead_code)]
#[allow(unused_imports)]

mod graphics;
//mod gui;
//mod interactions;
//mod overlay;
//mod state;

use core::slice;

use ash::vk;
use env_logger::Env;
use glam::f32::Vec4;
use log::{info, warn};
use wlx_capture::{wlr::WlrDmabufCapture, wayland::WlxClient, WlxCapture, frame::WlxFrame};

use crate::{graphics::{VkGraphics, VkDescriptor}};

fn main() {
    env_logger::Builder::from_env(Env::default().default_filter_or("info")).init();
    info!("Welcome to {} version {}!", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"));

//    let mut app = AppState {
//        fc: gui::font::FontCache::new(),
//        session: state::AppSession::load(),
//    };

    let wl = WlxClient::new().unwrap();
    let output_id = wl.outputs[0].id;
    let mut capture = WlrDmabufCapture::new(wl, output_id).unwrap();
    let rx = capture.init();

    let gfx = VkGraphics::new();
    let vert = gfx.create_shader(include_bytes!("shaders/vert-common.spv"), None);
    let frag_sprite = gfx.create_shader(
        include_bytes!("shaders/frag-sprite.spv"), 
        Some(vec![vk::DescriptorType::COMBINED_IMAGE_SAMPLER])
    );
    let frag_srgb = gfx.create_shader(
        include_bytes!("shaders/frag-srgb.spv"),
        Some(vec![vk::DescriptorType::COMBINED_IMAGE_SAMPLER])
    );
    let frag_glyph = gfx.create_shader(
        include_bytes!("shaders/frag-glyph.spv"), 
        Some(vec![vk::DescriptorType::COMBINED_IMAGE_SAMPLER, vk::DescriptorType::UNIFORM_BUFFER])
    );
    let frag_color = gfx.create_shader(
        include_bytes!("shaders/frag-color.spv"), 
        Some(vec![vk::DescriptorType::UNIFORM_BUFFER])
    );

    let pipeline = gfx.create_pipeline(vert, frag_color, gfx.swapchain_format);

    let color_buf = gfx.create_buffer(vk::BufferUsageFlags::UNIFORM_BUFFER, &[Vec4::new(1.0, 0.0, 1.0, 1.0); 16]);

    gfx.render_loop(|| {
        let frame = gfx.create_frame();

        unsafe { gfx.device.reset_command_pool(frame.command_pool, vk::CommandPoolResetFlags::RELEASE_RESOURCES) }.unwrap();

        let (present_index, _) = unsafe {
            gfx.swapchain_loader.acquire_next_image(
                gfx.swapchain, 
                std::u64::MAX, 
                frame.present_semaphore, 
                vk::Fence::null()
            ).unwrap()
        };
        
        let command_buffer_begin_info = vk::CommandBufferBeginInfo::builder()
            .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT)
            .build();

        unsafe { gfx.device.begin_command_buffer(frame.command_buffer, &command_buffer_begin_info) }.unwrap();

        let image = gfx.present_images[present_index as usize];

        let image_memory_barrier = vk::ImageMemoryBarrier2::builder()
        .src_stage_mask(vk::PipelineStageFlags2::TOP_OF_PIPE)
        .dst_stage_mask(vk::PipelineStageFlags2::COLOR_ATTACHMENT_OUTPUT)
        .dst_access_mask(vk::AccessFlags2::COLOR_ATTACHMENT_WRITE)
        .old_layout(vk::ImageLayout::UNDEFINED)
        .new_layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL)
        .image(image)
        .subresource_range(vk::ImageSubresourceRange::builder().aspect_mask(vk::ImageAspectFlags::COLOR).level_count(1).layer_count(1).build())
        .build();

        unsafe { gfx.device.cmd_pipeline_barrier2(frame.command_buffer, &vk::DependencyInfo::builder().image_memory_barriers(slice::from_ref(&image_memory_barrier)).build()) };
        
        let color_attachment = vk::RenderingAttachmentInfo::builder()
            .image_view(gfx.present_image_views[present_index as usize])
            .image_layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL)
            .load_op(vk::AttachmentLoadOp::CLEAR)
            .store_op(vk::AttachmentStoreOp::STORE)
            .clear_value(vk::ClearValue {
                color: vk::ClearColorValue {
                    float32: [0.0, 0.0, 0.0, 1.0]
                }
            });

        let rendering_info = vk::RenderingInfo::builder()
            .render_area(vk::Rect2D::builder().extent(vk::Extent2D::builder().width(1600).height(900).build()).build())
            .layer_count(1)
            .color_attachments(slice::from_ref(&color_attachment))
            .build();

        
        unsafe { gfx.device.cmd_begin_rendering(frame.command_buffer, &rendering_info) };

        let descriptor = VkDescriptor::Buffer(color_buf.clone());
        pipeline.bind_descriptors(slice::from_ref(&descriptor));
        pipeline.render(&frame, vk::Rect2D {
            offset: vk::Offset2D { x: 0, y: 0 },
            extent: vk::Extent2D { width: 1600, height: 900 }
        });

        unsafe { gfx.device.cmd_end_rendering(frame.command_buffer) };


        let image_memory_barrier = vk::ImageMemoryBarrier2::builder()
            .src_stage_mask(vk::PipelineStageFlags2::COLOR_ATTACHMENT_OUTPUT)
            .src_access_mask(vk::AccessFlags2::COLOR_ATTACHMENT_WRITE)
            .dst_stage_mask(vk::PipelineStageFlags2::BOTTOM_OF_PIPE)
            .old_layout(vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL)
            .new_layout(vk::ImageLayout::PRESENT_SRC_KHR)
            .image(image)
            .subresource_range(vk::ImageSubresourceRange::builder().aspect_mask(vk::ImageAspectFlags::COLOR).level_count(1).layer_count(1).build())
            .build();

        unsafe {
            gfx.device.cmd_pipeline_barrier2(frame.command_buffer, &vk::DependencyInfo::builder().image_memory_barriers(slice::from_ref(&image_memory_barrier)).build());
        };

        unsafe { gfx.device.end_command_buffer(frame.command_buffer) }.unwrap();

        let wait_semaphores = [frame.present_semaphore];
        let wait_dst_stage_mask = [vk::PipelineStageFlags::COLOR_ATTACHMENT_OUTPUT];

        let submit_info = vk::SubmitInfo::builder()
            .wait_semaphores(&wait_semaphores)
            .wait_dst_stage_mask(&wait_dst_stage_mask)
            .command_buffers(slice::from_ref(&frame.command_buffer))
            .signal_semaphores(slice::from_ref(&frame.render_semaphore));

        unsafe { gfx.device.queue_submit(gfx.present_queue, slice::from_ref(&submit_info), frame.fence) }.unwrap();

        let present_info = vk::PresentInfoKHR::builder()
            .wait_semaphores(slice::from_ref(&frame.present_semaphore))
            .swapchains(slice::from_ref(&gfx.swapchain))
            .image_indices(slice::from_ref(&present_index))
            .build();

        unsafe { gfx.swapchain_loader.queue_present(gfx.present_queue, &present_info).unwrap() };
    });

    unsafe { gfx.device.device_wait_idle().unwrap() };
}

