use core::slice;
use std::{sync::Arc, slice::Iter, io::Cursor, error::Error, borrow::{Cow, BorrowMut}, cell::RefCell, fs::File, os::fd::{FromRawFd, IntoRawFd}, mem};

use ash::{extensions::{
    ext::DebugUtils,
    khr::{Surface,Swapchain, self},
}, util::Align};

use ash::vk;
use cstr::cstr;
use glam::f32::Vec4;
use libc::c_char;
use log::{info,error};
use raw_window_handle::*;
use smallvec::smallvec;
use std::env;
use std::ffi::CStr;
use winit::{event_loop::{EventLoop, self, ControlFlow}, window::{WindowBuilder, Window}, event::{WindowEvent, KeyboardInput, ElementState, VirtualKeyCode, Event}, platform::run_return::EventLoopExtRunReturn};
use wlx_capture::frame::{DmabufFrame, DRM_FORMAT_ABGR8888, DRM_FORMAT_XBGR8888, DRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB8888};

#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct Vertex {
    pub in_pos: Vec4,
    pub in_uv: Vec4,
}

const APP_NAME: &str = env!("CARGO_PKG_NAME");
pub const INDICES : [u16; 6] = [2, 1, 0, 1, 2, 3];

pub const VERTICES : [Vertex; 4] = [
        Vertex{ in_pos: Vec4::new(0.0, 0.0, 0.0, 0.0), in_uv: Vec4::new(0.0, 0.0, 0.0, 0.0) },
        Vertex{ in_pos: Vec4::new(0.0, 1.0, 0.0, 0.0), in_uv: Vec4::new(0.0, 1.0, 0.0, 0.0) },
        Vertex{ in_pos: Vec4::new(1.0, 0.0, 0.0, 0.0), in_uv: Vec4::new(1.0, 0.0, 0.0, 0.0) },
        Vertex{ in_pos: Vec4::new(1.0, 1.0, 0.0, 0.0), in_uv: Vec4::new(1.0, 1.0, 0.0, 0.0) },
    ];

// Simple offset_of macro akin to C++ offsetof
#[macro_export]
macro_rules! offset_of {
    ($base:path, $field:ident) => {{
        #[allow(unused_unsafe)]
        unsafe {
            let b: $base = mem::zeroed();
            std::ptr::addr_of!(b.$field) as isize - std::ptr::addr_of!(b) as isize
        }
    }};
}

pub struct VkGraphics {
    pub event_loop: RefCell<EventLoop<()>>,
    pub entry: ash::Entry,

    pub instance: ash::Instance,
    pub device: ash::Device,

    pub surface_loader: Surface,
    pub swapchain_loader: Swapchain,
    pub window: winit::window::Window,

    pub device_properies: vk::PhysicalDeviceProperties,
    pub device_memory_properties: vk::PhysicalDeviceMemoryProperties,
    pub queue_family_index: u32,
    pub present_queue: vk::Queue,

    pub surface: vk::SurfaceKHR,
    pub surface_format: vk::SurfaceFormatKHR,
    pub surface_resolution: vk::Extent2D,

    pub swapchain: vk::SwapchainKHR,
    pub swapchain_format: vk::Format,
    pub present_images: Vec<vk::Image>,
    pub present_image_views: Vec<vk::ImageView>,

    pub pool: vk::CommandPool,
    pub draw_command_buffer: vk::CommandBuffer,
    pub setup_command_buffer: vk::CommandBuffer,

    pub draw_commands_reuse_fence: vk::Fence,
    pub setup_commands_reuse_fence: vk::Fence,

    #[cfg(debug_assertions)]
    pub debug_utils_loader: DebugUtils,
    #[cfg(debug_assertions)]
    pub debug_call_back: vk::DebugUtilsMessengerEXT,
}

impl VkGraphics {
    pub fn new() -> Arc<Self> {
        unsafe {
            let window_size = [1920, 1080];

            let event_loop = EventLoop::new();
            let window = WindowBuilder::new()
                .with_title("Vulkan")
                .with_inner_size(winit::dpi::LogicalSize::new(
                    window_size[0],
                    window_size[1],
                ))
                .build(&event_loop)
                .unwrap();

            let entry = ash::Entry::load().unwrap();
            let app_name = cstr!(APP_NAME);
            let layer_names = [
                #[cfg(debug_assertions)]
                cstr!("VK_LAYER_KHRONOS_validation"),
            ];
            let layers_names_raw: Vec<*const c_char> = layer_names
                .iter()
                .map(|raw_name| raw_name.as_ptr())
                .collect();

            let mut extension_names = ash_window::enumerate_required_extensions(window.raw_display_handle())
                .unwrap()
                .to_vec();

            #[cfg(debug_assertions)]
            extension_names.push(DebugUtils::name().as_ptr());

            let appinfo = vk::ApplicationInfo::builder()
                .application_name(app_name)
                .application_version(0)
                .engine_name(app_name)
                .engine_version(0)
                .api_version(vk::make_api_version(0, 1, 3, 0));

            let create_info = vk::InstanceCreateInfo::builder()
                .application_info(&appinfo)
                .enabled_layer_names(&layers_names_raw)
                .enabled_extension_names(&extension_names)
                .flags(vk::InstanceCreateFlags::default());

            let instance: ash::Instance = entry
                .create_instance(&create_info, None)
                .expect("Could not create Vulkan instance.");

            #[cfg(debug_assertions)]
            let (debug_utils_loader, debug_call_back) = 
            {
                let loader = DebugUtils::new(&entry, &instance);
                let info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
                    .message_severity(
                        vk::DebugUtilsMessageSeverityFlagsEXT::ERROR
                            | vk::DebugUtilsMessageSeverityFlagsEXT::WARNING
                            | vk::DebugUtilsMessageSeverityFlagsEXT::INFO
                            | vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE,
                    )
                    .message_type(
                        vk::DebugUtilsMessageTypeFlagsEXT::GENERAL
                            | vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION
                            | vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE,
                    )
                    .pfn_user_callback(Some(vulkan_debug_callback))
                    .build();

                let callback = loader
                    .create_debug_utils_messenger(&info, None)
                    .unwrap();
                (loader, callback)
            };

            let surface = ash_window::create_surface(
                &entry,
                &instance,
                window.raw_display_handle(),
                window.raw_window_handle(),
                None,
            )
            .unwrap();

            let surface_loader = Surface::new(&entry, &instance);

            let pdevices = instance
                .enumerate_physical_devices()
                .expect("Physical device error");

            let (pdevice, queue_family_index) = pdevices
                .iter()
                .find_map(|pdevice| {
                    instance
                        .get_physical_device_queue_family_properties(*pdevice)
                        .iter()
                        .enumerate()
                        .find_map(|(index, info)| {
                            let supports_graphic_and_surface =
                                info.queue_flags.contains(vk::QueueFlags::GRAPHICS)
                                    && surface_loader
                                        .get_physical_device_surface_support(
                                            *pdevice,
                                            index as u32,
                                            surface,
                                        )
                                        .unwrap();
                            if supports_graphic_and_surface {
                                Some((*pdevice, index))
                            } else {
                                None
                            }
                        })
                })
                .expect("Couldn't find suitable device.");

            let queue_family_index = queue_family_index as u32;
            let device_extension_names_raw = [
                Swapchain::name().as_ptr(),
                vk::KhrExternalMemoryFn::name().as_ptr(),
                vk::KhrExternalMemoryFdFn::name().as_ptr(),
                vk::ExtExternalMemoryDmaBufFn::name().as_ptr(),
                vk::ExtImageDrmFormatModifierFn::name().as_ptr(),
            ];

            let priorities = [1.0];

            let queue_info = vk::DeviceQueueCreateInfo::builder()
                .queue_family_index(queue_family_index)
                .queue_priorities(&priorities);

            let physical_device_features = vk::PhysicalDeviceFeatures::builder().shader_clip_distance(true).build();
            let mut physical_device_vulkan_13_features = vk::PhysicalDeviceVulkan13Features::builder().dynamic_rendering(true).synchronization2(true).build();

            let mut features = vk::PhysicalDeviceFeatures2::builder()
                .features(physical_device_features)
                .push_next(&mut physical_device_vulkan_13_features)
                .build();

            let device_create_info = vk::DeviceCreateInfo::builder()
                .queue_create_infos(std::slice::from_ref(&queue_info))
                .enabled_extension_names(&device_extension_names_raw)
                .push_next(&mut features);

            let device: ash::Device = instance
                .create_device(pdevice, &device_create_info, None)
                .unwrap();

            let present_queue = device.get_device_queue(queue_family_index, 0);

            let surface_format = surface_loader
                .get_physical_device_surface_formats(pdevice, surface)
                .unwrap()[0];

            let surface_capabilities = surface_loader
                .get_physical_device_surface_capabilities(pdevice, surface)
                .unwrap();

            let desired_image_count = surface_capabilities.min_image_count;
            let surface_resolution = match surface_capabilities.current_extent.width {
                std::u32::MAX => vk::Extent2D {
                    width: window_size[0],
                    height: window_size[1],
                },
                _ => surface_capabilities.current_extent,
            };

            let pre_transform = if surface_capabilities
                .supported_transforms
                .contains(vk::SurfaceTransformFlagsKHR::IDENTITY)
            {
                vk::SurfaceTransformFlagsKHR::IDENTITY
            } else {
                surface_capabilities.current_transform
            };
            let present_modes = surface_loader
                .get_physical_device_surface_present_modes(pdevice, surface)
                .unwrap();
            let present_mode = present_modes
                .iter()
                .cloned()
                .find(|&mode| mode == vk::PresentModeKHR::MAILBOX)
                .unwrap_or(vk::PresentModeKHR::FIFO);
            
            let swapchain_loader = Swapchain::new(&instance, &device);

            #[allow(unused)]
            let dmabuf_loader = vk::ExtImageDrmFormatModifierFn::load(|name| {
                std::mem::transmute(instance.get_device_proc_addr(device.handle(), name.as_ptr()))
            });

            let swapchain_create_info = vk::SwapchainCreateInfoKHR::builder()
                .surface(surface)
                .min_image_count(desired_image_count)
                .image_color_space(surface_format.color_space)
                .image_format(surface_format.format)
                .image_extent(surface_resolution)
                .image_usage(vk::ImageUsageFlags::COLOR_ATTACHMENT)
                .image_sharing_mode(vk::SharingMode::EXCLUSIVE)
                .pre_transform(pre_transform)
                .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
                .present_mode(present_mode)
                .clipped(true)
                .image_array_layers(1);

            let swapchain = swapchain_loader
                .create_swapchain(&swapchain_create_info, None)
                .unwrap();

            let pool_create_info = vk::CommandPoolCreateInfo::builder()
                .flags(vk::CommandPoolCreateFlags::RESET_COMMAND_BUFFER)
                .queue_family_index(queue_family_index);

            let pool = device.create_command_pool(&pool_create_info, None).unwrap();

            let command_buffer_allocate_info = vk::CommandBufferAllocateInfo::builder()
                .command_buffer_count(2)
                .command_pool(pool)
                .level(vk::CommandBufferLevel::PRIMARY);

            let command_buffers = device
                .allocate_command_buffers(&command_buffer_allocate_info)
                .unwrap();

            let setup_command_buffer = command_buffers[0];
            let draw_command_buffer = command_buffers[1];
            
            let present_images = swapchain_loader.get_swapchain_images(swapchain).unwrap();
            let present_image_views: Vec<vk::ImageView> = present_images
                .iter()
                .map(|&image| {
                    let create_view_info = vk::ImageViewCreateInfo::builder()
                        .view_type(vk::ImageViewType::TYPE_2D)
                        .format(surface_format.format)
                        .components(vk::ComponentMapping {
                            r: vk::ComponentSwizzle::R,
                            g: vk::ComponentSwizzle::G,
                            b: vk::ComponentSwizzle::B,
                            a: vk::ComponentSwizzle::A,
                        })
                        .subresource_range(vk::ImageSubresourceRange {
                            aspect_mask: vk::ImageAspectFlags::COLOR,
                            base_mip_level: 0,
                            level_count: 1,
                            base_array_layer: 0,
                            layer_count: 1,
                        })
                        .image(image);
                    device.create_image_view(&create_view_info, None).unwrap()
                })
                .collect();
            let device_memory_properties = instance.get_physical_device_memory_properties(pdevice);

            let device_properies = instance.get_physical_device_properties(pdevice);

            let fence_create_info =
                vk::FenceCreateInfo::builder().flags(vk::FenceCreateFlags::SIGNALED);

            let draw_commands_reuse_fence = device
                .create_fence(&fence_create_info, None)
                .expect("Create fence failed.");
            let setup_commands_reuse_fence = device
                .create_fence(&fence_create_info, None)
                .expect("Create fence failed.");
            
            let me = Self {
                event_loop: RefCell::new(event_loop),
                entry,
                instance,
                device,
                queue_family_index,
                device_properies,
                device_memory_properties,
                window,
                surface_loader,
                surface_format,
                present_queue,
                surface_resolution,
                swapchain_loader,
                swapchain,
                swapchain_format: surface_format.format,
                present_images,
                present_image_views,
                pool,
                draw_command_buffer,
                setup_command_buffer,
                draw_commands_reuse_fence,
                setup_commands_reuse_fence,
                surface,
                #[cfg(debug_assertions)]
                debug_call_back,
                #[cfg(debug_assertions)]
                debug_utils_loader,
            };
            Arc::new(me)
        }
    }

    pub fn render_loop<F: Fn()>(&self, f: F) {
        self.event_loop
            .borrow_mut()
            .run_return(|event, _, control_flow| {
                *control_flow = ControlFlow::Poll;
                match event {
                    Event::WindowEvent {
                        event:
                            WindowEvent::CloseRequested
                            | WindowEvent::KeyboardInput {
                                input:
                                    KeyboardInput {
                                        state: ElementState::Pressed,
                                        virtual_keycode: Some(VirtualKeyCode::Escape),
                                        ..
                                    },
                                ..
                            },
                        ..
                    } => *control_flow = ControlFlow::Exit,
                    Event::MainEventsCleared => f(),
                    _ => (),
                }
            });
    }

    pub fn create_frame(self: &Arc<Self>) -> VkFrame {
        VkFrame::new(self.clone())
    }

    pub fn create_shader(self: &Arc<Self>, spv_bytes: &[u8], descriptor_types: Option<Vec<vk::DescriptorType>>) -> Arc<VkShader> {
        VkShader::new(self.clone(), spv_bytes, descriptor_types)
    }

    pub fn create_pipeline(self: &Arc<Self>, vert: Arc<VkShader>, frag: Arc<VkShader>, format: vk::Format) -> VkPipeline {
        VkPipeline::new(self.clone(), vert, frag, format)
    }

    pub fn create_buffer<T>(self: &Arc<Self>, usage: vk::BufferUsageFlags, data: &[T]) -> Arc<VkBuffer>
    where T: Copy {
        VkBuffer::new(self.clone(), usage, data)
    }
}

impl Drop for VkGraphics {
    fn drop(&mut self) {
        unsafe {
            self.device.device_wait_idle().unwrap();
            self.device
                .destroy_fence(self.draw_commands_reuse_fence, None);
            self.device
                .destroy_fence(self.setup_commands_reuse_fence, None);
            for &image_view in self.present_image_views.iter() {
                self.device.destroy_image_view(image_view, None);
            }
            self.device.destroy_command_pool(self.pool, None);
            self.swapchain_loader
                .destroy_swapchain(self.swapchain, None);
            self.surface_loader.destroy_surface(self.surface, None);
            self.debug_utils_loader
                .destroy_debug_utils_messenger(self.debug_call_back, None);
            self.instance.destroy_instance(None);
            self.device.destroy_device(None);
        }
    }
}

pub struct VkFrame {
    pub graphics: Arc<VkGraphics>,

    pub command_pool: vk::CommandPool,
    pub command_buffer: vk::CommandBuffer,

    pub present_semaphore: vk::Semaphore,
    pub render_semaphore: vk::Semaphore,

    pub fence: vk::Fence,
}

impl VkFrame {
    pub fn new(graphics: Arc<VkGraphics>) -> Self {
        let command_pool = unsafe { graphics.device.create_command_pool(&vk::CommandPoolCreateInfo::default(), None) }.unwrap();
        let command_buffer = unsafe { graphics.device.allocate_command_buffers(&vk::CommandBufferAllocateInfo::builder().command_pool(command_pool).command_buffer_count(1).build()) }.unwrap()[0];
        let present_semaphore = unsafe { graphics.device.create_semaphore(&vk::SemaphoreCreateInfo::default(), None) }.unwrap();
        let render_semaphore = unsafe { graphics.device.create_semaphore(&vk::SemaphoreCreateInfo::default(), None) }.unwrap();
        let fence = unsafe { graphics.device.create_fence(&vk::FenceCreateInfo::builder().flags(vk::FenceCreateFlags::SIGNALED).build(), None) }.unwrap();

        Self {
            graphics,
            command_pool,
            command_buffer,
            present_semaphore,
            render_semaphore,
            fence,
        }
    }
}

impl Drop for VkFrame {
    fn drop(&mut self) {
        unsafe {
            self.graphics.device.destroy_command_pool(self.command_pool, None);
            self.graphics
                .device
                .destroy_semaphore(self.present_semaphore, None);
            self.graphics
                .device
                .destroy_semaphore(self.render_semaphore, None);
            self.graphics.device.destroy_fence(self.fence, None);
        }
    }
}

pub struct VkBuffer {
    pub graphics: Arc<VkGraphics>,
    pub buffer: vk::Buffer,
    pub memory: vk::DeviceMemory,
}

impl VkBuffer
{
    pub fn new<T>(graphics: Arc<VkGraphics>, usage: vk::BufferUsageFlags, data: &[T]) -> Arc<Self>
    where T: Copy 
    {
        unsafe {
            let buffer_size = std::mem::size_of::<T>() * data.len();

            let buffer_create_info = vk::BufferCreateInfo::builder()
                .size(buffer_size as _)
                .usage(usage)
                .sharing_mode(vk::SharingMode::EXCLUSIVE);

            let buffer = graphics.device.create_buffer(&buffer_create_info, None).unwrap();

            let memory_req = graphics.device.get_buffer_memory_requirements(buffer);

            let memory_index = find_memorytype_index(
                &memory_req,
                &graphics.device_memory_properties,
                vk::MemoryPropertyFlags::HOST_VISIBLE | vk::MemoryPropertyFlags::HOST_COHERENT,
            )
            .expect("Unable to find suitable memory index for vertex buffer.");

            let memory_allocate_info = vk::MemoryAllocateInfo::builder()
                .allocation_size(memory_req.size)
                .memory_type_index(memory_index)
                .build();

            let memory = graphics
                .device
                .allocate_memory(&memory_allocate_info, None)
                .unwrap();

            let memory_ptr = graphics
                .device
                .map_memory(memory, 0, memory_req.size, vk::MemoryMapFlags::empty())
                .unwrap();

            let mut slice = Align::<T>::new(memory_ptr, std::mem::align_of::<T>() as _, memory_req.size);
            slice.copy_from_slice(data);

            graphics.device.unmap_memory(memory);
            graphics.device.bind_buffer_memory(buffer, memory, 0).unwrap();

            Arc::new(Self {
                graphics,
                buffer,
                memory,
            })
        }
    }
}

impl Drop for VkBuffer{
    fn drop(&mut self) {
        unsafe {
            self.graphics.device.free_memory(self.memory, None);
            self.graphics.device.destroy_buffer(self.buffer, None);
        }
    }
}

pub struct VkImage {
    pub graphics: Arc<VkGraphics>,
    pub image: vk::Image,
    pub memory: vk::DeviceMemory,
    pub view: Option<vk::ImageView>,
    pub sampler: Option<vk::Sampler>,
    pub buffer: Option<Arc<VkBuffer>>,
}

impl VkImage {
    pub fn new_empty(graphics: Arc<VkGraphics>, width: u32, height: u32) -> Self {
        todo!();
    }

    pub fn new_from_bytes(&self, graphics: Arc<VkGraphics>, width: u32, height: u32, format: vk::Format, data: &[u8]) -> Self {
        let image_extent = vk::Extent3D { width, height, depth: 1 };
        let image = {
            let image_create_info = vk::ImageCreateInfo::builder()
                .image_type(vk::ImageType::TYPE_2D)
                .format(vk::Format::R8G8B8A8_UNORM)
                .extent(image_extent)
                .mip_levels(1)
                .array_layers(1)
                .samples(vk::SampleCountFlags::TYPE_1)
                .tiling(vk::ImageTiling::OPTIMAL)
                .usage(vk::ImageUsageFlags::TRANSFER_DST 
                    | vk::ImageUsageFlags::TRANSFER_SRC 
                    | vk::ImageUsageFlags::SAMPLED)
                .sharing_mode(vk::SharingMode::EXCLUSIVE);

            unsafe { graphics.device.create_image(&image_create_info, None).unwrap() }
        };

        let image_buffer = VkBuffer::new(graphics.clone(), vk::BufferUsageFlags::TRANSFER_SRC, data);
        let memory_requirements = unsafe { graphics.device.get_image_memory_requirements(image) };
        let memory_type_index = find_memorytype_index(
            &memory_requirements,
            &graphics.device_memory_properties,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        ).unwrap();

        let memory = {
            let alloc_info = vk::MemoryAllocateInfo::builder()
                .allocation_size(memory_requirements.size)
                .memory_type_index(memory_type_index)
                .build();

            unsafe { graphics.device.allocate_memory(&alloc_info, None).unwrap() }
        };

        unsafe { graphics.device.bind_image_memory(image, memory, 0).unwrap() };

        record_submit_commandbuffer(
            &graphics.device,
            graphics.setup_command_buffer,
            graphics.setup_commands_reuse_fence,
            graphics.present_queue,
            &[],
            &[],
            &[],
            |device, texture_command_buffer| {
                let barrier = vk::ImageMemoryBarrier {
                    dst_access_mask: vk::AccessFlags::TRANSFER_WRITE,
                    new_layout: vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                    image,
                    subresource_range: vk::ImageSubresourceRange {
                        aspect_mask: vk::ImageAspectFlags::COLOR,
                        level_count: 1,
                        layer_count: 1,
                        ..Default::default()
                    },
                    ..Default::default()
                };

                unsafe { device.cmd_pipeline_barrier(
                                    texture_command_buffer,
                                    vk::PipelineStageFlags::BOTTOM_OF_PIPE,
                                    vk::PipelineStageFlags::TRANSFER,
                                    vk::DependencyFlags::empty(),
                                    &[],
                                    &[],
                                    &[barrier],
                                ) };

                let buffer_copy_regions = vk::BufferImageCopy::builder()
                    .image_subresource(
                        vk::ImageSubresourceLayers::builder()
                        .aspect_mask(vk::ImageAspectFlags::COLOR)
                        .layer_count(1)
                        .build()
                    )
                    .image_extent(image_extent)
                    .build();

                unsafe { device.cmd_copy_buffer_to_image(
                                    texture_command_buffer,
                                    image_buffer.buffer,
                                    image,
                                    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                                    &[buffer_copy_regions],
                                ) };

                let barrier_end = vk::ImageMemoryBarrier {
                    src_access_mask: vk::AccessFlags::TRANSFER_WRITE,
                    dst_access_mask: vk::AccessFlags::SHADER_READ,
                    old_layout: vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                    new_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                    image,
                    subresource_range: vk::ImageSubresourceRange {
                        aspect_mask: vk::ImageAspectFlags::COLOR,
                        level_count: 1,
                        layer_count: 1,
                        ..Default::default()
                    },
                    ..Default::default()
                };

                unsafe { device.cmd_pipeline_barrier(
                                    texture_command_buffer,
                                    vk::PipelineStageFlags::TRANSFER,
                                    vk::PipelineStageFlags::FRAGMENT_SHADER,
                                    vk::DependencyFlags::empty(),
                                    &[],
                                    &[],
                                    &[barrier_end],
                                ) };

            },
        );

        Self {
            graphics: graphics.clone(),
            image,
            memory,
            buffer: Some(image_buffer),
            view: None,
            sampler: None,
        }
    }

    pub fn new_from_dmabuf(graphics: Arc<VkGraphics>, frame: &DmabufFrame) -> Self {
        debug_assert!(frame.num_planes == 1);
        let plane = &frame.planes[0];
        debug_assert!(plane.fd.is_some());

        let format = match frame.format.fourcc {
            DRM_FORMAT_ABGR8888 => vk::Format::R8G8B8A8_UNORM,
            DRM_FORMAT_XBGR8888 => vk::Format::R8G8B8A8_UNORM,
            DRM_FORMAT_ARGB8888 => vk::Format::B8G8R8A8_UNORM,
            DRM_FORMAT_XRGB8888 => vk::Format::B8G8R8A8_UNORM,
            _ => panic!("Unsupported dmabuf format {:x}", frame.format.fourcc),
        };

        let image = {
            let layout = vk::SubresourceLayout::builder()
                        .offset(plane.offset as _)
                        .row_pitch(plane.stride as _)
                        .size(0)
                        .array_pitch(0)
                        .depth_pitch(0)
                        .build();

            let mut drm_info = vk::ImageDrmFormatModifierExplicitCreateInfoEXT::builder()
                .drm_format_modifier(frame.format.modifier)
                .plane_layouts(slice::from_ref(&layout));

            let mut mem_info = vk::ExternalMemoryImageCreateInfo::builder()
                .handle_types(vk::ExternalMemoryHandleTypeFlags::DMA_BUF_EXT);

            let image_create_info = vk::ImageCreateInfo::builder()
                .image_type(vk::ImageType::TYPE_2D)
                .format(format)
                .extent(vk::Extent3D {
                    width: frame.format.width,
                    height: frame.format.height,
                    depth: 1,
                })
                .mip_levels(1)
                .array_layers(1)
                .samples(vk::SampleCountFlags::TYPE_1)
                .tiling(vk::ImageTiling::DRM_FORMAT_MODIFIER_EXT)
                .usage(vk::ImageUsageFlags::TRANSFER_SRC | vk::ImageUsageFlags::SAMPLED)
                .sharing_mode(vk::SharingMode::EXCLUSIVE)
                .push_next(&mut drm_info)
                .push_next(&mut mem_info)
                .build();

            unsafe { graphics.device.create_image(&image_create_info, None).unwrap() }
        };

        let memory_requirements = unsafe { graphics.device.get_image_memory_requirements(image) };
        let memory_type_index = find_memorytype_index(
            &memory_requirements,
            &graphics.device_memory_properties,
            vk::MemoryPropertyFlags::DEVICE_LOCAL,
        ).unwrap();

        let memory = {
            let mut fd_info = vk::ImportMemoryFdInfoKHR::builder()
                .handle_type(vk::ExternalMemoryHandleTypeFlags::DMA_BUF_EXT)
                .fd(plane.fd.unwrap())
                .build();

            let mut ded_req = vk::MemoryDedicatedAllocateInfo::builder()
                .image(image)
                .build();

            let alloc_info = vk::MemoryAllocateInfo::builder()
                .allocation_size(memory_requirements.size)
                .memory_type_index(memory_type_index)
                .push_next(&mut fd_info)
                .push_next(&mut ded_req)
                .build();

            unsafe { graphics.device.allocate_memory(&alloc_info, None).unwrap() }
        };

        unsafe { graphics.device.bind_image_memory(image, memory, 0).unwrap() };

        Self {
            graphics: graphics.clone(),
            image,
            memory,
            buffer: None,
            view: None,
            sampler: None,
        }
    }
}

impl Drop for VkImage {
    fn drop(&mut self) {
        unsafe {
            if let Some(buffer) = self.buffer.as_ref() {
                self.graphics.device.free_memory(buffer.memory, None);
                self.graphics.device.destroy_buffer(buffer.buffer, None);
            }
            if let Some(view) = self.view {
                self.graphics.device.destroy_image_view(view, None);
            }
            self.graphics.device.free_memory(self.memory, None);
            self.graphics.device.destroy_image(self.image, None);
        }
    }
}

const ENTRY_POINT_MAIN: &'static CStr = cstr!("main");
pub struct VkShader {
    pub graphics: Arc<VkGraphics>,
    pub module: vk::ShaderModule,
    pub descriptor_types: Option<Vec<vk::DescriptorType>>,
}

impl VkShader {
    fn new(graphics: Arc<VkGraphics>, bytes: &[u8], descriptor_types: Option<Vec<vk::DescriptorType>>) -> Arc<Self> {
        let mut spv = ash::util::read_spv(&mut Cursor::new(bytes)).unwrap();
        let module_create_info = vk::ShaderModuleCreateInfo::builder().code(&mut spv);
        let module = unsafe { graphics.device.create_shader_module(&module_create_info, None).unwrap() };

        Arc::new(Self {
            graphics,
            module,
            descriptor_types,
        })
    }
}

impl Drop for VkShader {
    fn drop(&mut self) {
        unsafe {
            self.graphics.device.destroy_shader_module(self.module, None);
        }
    }
}

pub struct VkPipeline {
    pub graphics: Arc<VkGraphics>,
    pub pipeline: vk::Pipeline,
    pub pipeline_layout: vk::PipelineLayout,
    pub desc_set_layouts: Vec<vk::DescriptorSetLayout>,
    pub descriptor_pool: vk::DescriptorPool,
    pub descriptor_sets: Vec<vk::DescriptorSet>,
    pub index_buffer: Arc<VkBuffer>,
    pub vertex_buffer: Arc<VkBuffer>,
}

impl VkPipeline {
    pub fn new(graphics: Arc<VkGraphics>, vert: Arc<VkShader>, frag: Arc<VkShader>, format: vk::Format) -> Self {
        let shader_stage_create_infos = [
            vk::PipelineShaderStageCreateInfo {
                module: vert.module,
                p_name: ENTRY_POINT_MAIN.as_ptr(),
                stage: vk::ShaderStageFlags::VERTEX,
                ..Default::default()
            },
            vk::PipelineShaderStageCreateInfo {
                module: frag.module,
                p_name: ENTRY_POINT_MAIN.as_ptr(),
                stage: vk::ShaderStageFlags::FRAGMENT,
                ..Default::default()
            },
        ];

        let vertex_input_binding_descriptions = [vk::VertexInputBindingDescription {
            binding: 0,
            stride: mem::size_of::<Vertex>() as u32,
            input_rate: vk::VertexInputRate::VERTEX,
        }];
        
        let vertex_input_attribute_descriptions = [
            vk::VertexInputAttributeDescription {
                location: 0,
                binding: 0,
                format: vk::Format::R32G32_SFLOAT,
                offset: offset_of!(Vertex, in_pos) as u32,
            },
            vk::VertexInputAttributeDescription {
                location: 1,
                binding: 0,
                format: vk::Format::R32G32_SFLOAT,
                offset: offset_of!(Vertex, in_uv) as u32,
            },
        ];

        let vertex_input_state_info = vk::PipelineVertexInputStateCreateInfo::builder()
            .vertex_attribute_descriptions(&vertex_input_attribute_descriptions)
            .vertex_binding_descriptions(&vertex_input_binding_descriptions)
            .build();

        let vertex_input_assembly_state_info = vk::PipelineInputAssemblyStateCreateInfo::builder()
            .topology(vk::PrimitiveTopology::TRIANGLE_LIST)
            .build();

        let desc_layout_bindings = frag.descriptor_types.iter().flatten().enumerate().map(|(i, &desc_type)| {
            vk::DescriptorSetLayoutBinding {
                binding: i as u32,
                descriptor_type: desc_type,
                descriptor_count: 1,
                stage_flags: vk::ShaderStageFlags::FRAGMENT,
                ..Default::default()
            }
        }).collect::<Vec<_>>();

        let descriptor_info =
            vk::DescriptorSetLayoutCreateInfo::builder()
            .bindings(&desc_layout_bindings);

        let desc_set_layouts = unsafe { 
            vec![graphics
            .device
            .create_descriptor_set_layout(&descriptor_info, None)
            .unwrap()]
        };

        let layout_create_info =
            vk::PipelineLayoutCreateInfo::builder().set_layouts(&desc_set_layouts);

        let pipeline_layout = unsafe {
            graphics
            .device
            .create_pipeline_layout(&layout_create_info, None)
            .unwrap() 
        };

        let viewport = vk::Viewport::builder().width(1.0).height(1.0).max_depth(1.0).build();
        let scissor = vk::Rect2D::builder().extent(vk::Extent2D { width: 1, height: 1 }).build();
        
        let viewport_state_info = vk::PipelineViewportStateCreateInfo::builder()
            .scissors(slice::from_ref(&scissor))
            .viewports(slice::from_ref(&viewport))
            .build();

        let rasterization_info = vk::PipelineRasterizationStateCreateInfo::builder()
            .front_face(vk::FrontFace::COUNTER_CLOCKWISE)
            .line_width(1.0)
            .polygon_mode(vk::PolygonMode::FILL)
            .build();

        let multisample_state_info = vk::PipelineMultisampleStateCreateInfo::builder()
            .rasterization_samples(vk::SampleCountFlags::TYPE_1)
            .build();
        
        let color_blend_attachment_states = [vk::PipelineColorBlendAttachmentState {
            blend_enable: 1,
            src_color_blend_factor: vk::BlendFactor::SRC_COLOR,
            dst_color_blend_factor: vk::BlendFactor::ONE_MINUS_DST_COLOR,
            color_blend_op: vk::BlendOp::ADD,
            src_alpha_blend_factor: vk::BlendFactor::ZERO,
            dst_alpha_blend_factor: vk::BlendFactor::ZERO,
            alpha_blend_op: vk::BlendOp::ADD,
            color_write_mask: vk::ColorComponentFlags::RGBA,
        }];

        let color_blend_state = vk::PipelineColorBlendStateCreateInfo::builder()
            .logic_op(vk::LogicOp::CLEAR)
            .attachments(&color_blend_attachment_states)
            .build();

        let dynamic_state = [vk::DynamicState::VIEWPORT, vk::DynamicState::SCISSOR];
        let dynamic_state_info =
            vk::PipelineDynamicStateCreateInfo::builder()
            .dynamic_states(&dynamic_state)
            .build();

        let mut pipeline_rendering_create_info = vk::PipelineRenderingCreateInfo::builder()
            .color_attachment_formats(slice::from_ref(&format));

        let info = vk::GraphicsPipelineCreateInfo::builder()
            .stages(&shader_stage_create_infos)
            .vertex_input_state(&vertex_input_state_info)
            .input_assembly_state(&vertex_input_assembly_state_info)
            .viewport_state(&viewport_state_info)
            .rasterization_state(&rasterization_info)
            .multisample_state(&multisample_state_info)
            .color_blend_state(&color_blend_state)
            .dynamic_state(&dynamic_state_info)
            .layout(pipeline_layout)
            .push_next(&mut pipeline_rendering_create_info)
            .build();
        
        let pipeline = unsafe { graphics.device.create_graphics_pipelines(vk::PipelineCache::null(), slice::from_ref(&info), None).unwrap()[0] };

        let descriptor_sizes = frag.descriptor_types.iter().flatten().map(|&desc_type| {
            vk::DescriptorPoolSize {
                ty: desc_type,
                descriptor_count: 1,
            }
        }).collect::<Vec<_>>();

        let descriptor_pool_info = vk::DescriptorPoolCreateInfo::builder()
            .pool_sizes(&descriptor_sizes)
            .max_sets(1)
            .build();

        let descriptor_pool = unsafe { graphics.device.create_descriptor_pool(&descriptor_pool_info, None).unwrap() };

        let desc_alloc_info = vk::DescriptorSetAllocateInfo::builder()
            .descriptor_pool(descriptor_pool)
            .set_layouts(&desc_set_layouts)
            .build();

        let descriptor_sets = unsafe { graphics.device.allocate_descriptor_sets(&desc_alloc_info).unwrap() };

        let index_buffer = graphics.create_buffer(vk::BufferUsageFlags::INDEX_BUFFER, &INDICES);
        let vertex_buffer = graphics.create_buffer(vk::BufferUsageFlags::VERTEX_BUFFER, &VERTICES);

        Self { 
            graphics,
            pipeline, 
            pipeline_layout,
            descriptor_pool,
            desc_set_layouts,
            descriptor_sets,
            index_buffer,
            vertex_buffer,
        }
    }

    pub fn render(&self, frame: &VkFrame, rect: vk::Rect2D) {
        unsafe {
            self.graphics.device.cmd_bind_pipeline(frame.command_buffer, vk::PipelineBindPoint::GRAPHICS, self.pipeline);

            let viewport = vk::Viewport::builder().width(rect.extent.width as _).height(rect.extent.height as _).max_depth(1.0).build();

            self.graphics.device.cmd_set_viewport(frame.command_buffer, 0, slice::from_ref(&viewport));
            self.graphics.device.cmd_set_scissor(frame.command_buffer, 0, slice::from_ref(&rect));

            self.graphics.device.cmd_bind_vertex_buffers(frame.command_buffer, 0, slice::from_ref(&self.vertex_buffer.buffer), &[0]);
            self.graphics.device.cmd_bind_index_buffer(frame.command_buffer, self.index_buffer.buffer, 0, vk::IndexType::UINT16);

            self.graphics.device.cmd_draw_indexed(frame.command_buffer, 6, 1, 0, 0, 1);
        }
    }

    pub fn bind_descriptors(&self, descriptors: &[VkDescriptor]) {
        let descriptor_write = descriptors.iter().enumerate().map(|(i, desciptor)| {
            match desciptor {
                VkDescriptor::Image(image) => {
                    let descriptor_image_info = vk::DescriptorImageInfo {
                        sampler: vk::Sampler::null(),
                        image_view: image.view.unwrap(),
                        image_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                    };
                    vk::WriteDescriptorSet::builder()
                        .dst_set(self.descriptor_sets[0])
                        .dst_binding(i as u32)
                        .descriptor_type(vk::DescriptorType::SAMPLED_IMAGE)
                        .image_info(&[descriptor_image_info])
                        .build()
                },
                VkDescriptor::Buffer(buffer) => {
                    let descriptor_buffer_info = vk::DescriptorBufferInfo {
                        buffer: buffer.buffer,
                        offset: 0,
                        range: vk::WHOLE_SIZE,
                    };
                    vk::WriteDescriptorSet::builder()
                        .dst_set(self.descriptor_sets[0])
                        .dst_binding(i as u32)
                        .descriptor_type(vk::DescriptorType::UNIFORM_BUFFER)
                        .buffer_info(&[descriptor_buffer_info])
                        .build()
                },
            }
        }).collect::<Vec<_>>();
        println!("x");
        unsafe { self.graphics.device.update_descriptor_sets(&descriptor_write, &[]) };
        println!("y");
    }
}

impl Drop for VkPipeline {
    fn drop(&mut self) {
        unsafe {
            self.graphics.device.destroy_pipeline(self.pipeline, None);
            self.graphics.device.destroy_pipeline_layout(self.pipeline_layout, None);
            self.graphics.device.destroy_descriptor_pool(self.descriptor_pool, None);
            for &desc_set_layout in self.desc_set_layouts.iter() {
                self.graphics.device.destroy_descriptor_set_layout(desc_set_layout, None);
            }
        }
    }
}

pub enum VkDescriptor {
    Image(Arc<VkImage>),
    Buffer(Arc<VkBuffer>),
}

pub fn find_memorytype_index(
    memory_req: &vk::MemoryRequirements,
    memory_prop: &vk::PhysicalDeviceMemoryProperties,
    flags: vk::MemoryPropertyFlags,
) -> Option<u32> {
    memory_prop.memory_types[..memory_prop.memory_type_count as _]
        .iter()
        .enumerate()
        .find(|(index, memory_type)| {
            (1 << index) & memory_req.memory_type_bits != 0
                && memory_type.property_flags & flags == flags
        })
        .map(|(index, _memory_type)| index as _)
}

/// Helper function for submitting command buffers. Immediately waits for the fence before the command buffer
/// is executed. That way we can delay the waiting for the fences by 1 frame which is good for performance.
/// Make sure to create the fence in a signaled state on the first use.
#[allow(clippy::too_many_arguments)]
pub fn record_submit_commandbuffer<F: FnOnce(&ash::Device, vk::CommandBuffer)>(
    device: &ash::Device,
    command_buffer: vk::CommandBuffer,
    command_buffer_reuse_fence: vk::Fence,
    submit_queue: vk::Queue,
    wait_mask: &[vk::PipelineStageFlags],
    wait_semaphores: &[vk::Semaphore],
    signal_semaphores: &[vk::Semaphore],
    f: F,
) {
    unsafe {
        device
            .wait_for_fences(&[command_buffer_reuse_fence], true, std::u64::MAX)
            .expect("Wait for fence failed.");

        device
            .reset_fences(&[command_buffer_reuse_fence])
            .expect("Reset fences failed.");

        device
            .reset_command_buffer(
                command_buffer,
                vk::CommandBufferResetFlags::RELEASE_RESOURCES,
            )
            .expect("Reset command buffer failed.");

        let command_buffer_begin_info = vk::CommandBufferBeginInfo::builder()
            .flags(vk::CommandBufferUsageFlags::ONE_TIME_SUBMIT);

        device
            .begin_command_buffer(command_buffer, &command_buffer_begin_info)
            .expect("Begin commandbuffer");
        f(device, command_buffer);
        device
            .end_command_buffer(command_buffer)
            .expect("End commandbuffer");

        let command_buffers = vec![command_buffer];

        let submit_info = vk::SubmitInfo::builder()
            .wait_semaphores(wait_semaphores)
            .wait_dst_stage_mask(wait_mask)
            .command_buffers(&command_buffers)
            .signal_semaphores(signal_semaphores);

        device
            .queue_submit(
                submit_queue,
                &[submit_info.build()],
                command_buffer_reuse_fence,
            )
            .expect("queue submit failed.");
    }
}

unsafe extern "system" fn vulkan_debug_callback(
    message_severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    message_type: vk::DebugUtilsMessageTypeFlagsEXT,
    p_callback_data: *const vk::DebugUtilsMessengerCallbackDataEXT,
    _user_data: *mut std::os::raw::c_void,
) -> vk::Bool32 {
    let callback_data = *p_callback_data;
    let message_id_number = callback_data.message_id_number;

    let message_id_name = if callback_data.p_message_id_name.is_null() {
        Cow::from("")
    } else {
        CStr::from_ptr(callback_data.p_message_id_name).to_string_lossy()
    };

    let message = if callback_data.p_message.is_null() {
        Cow::from("")
    } else {
        CStr::from_ptr(callback_data.p_message).to_string_lossy()
    };

    println!(
        "{message_severity:?}:\n{message_type:?} [{message_id_name} ({message_id_number})] : {message}\n",
    );

    vk::FALSE
}
